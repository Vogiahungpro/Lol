-- Enhanced Roblox Executor Client with Discord Bot Katabump API Integration
-- Updated to work with localhost:80 API endpoints and Discord bot sync
-- Version 2.1 - Enhanced error handling and fallback system

if _G.executed then return end
_G.executed = true

repeat task.wait() until game:IsLoaded()

-- Check for executor key
if not _G.EXECUTOR_KEY or _G.EXECUTOR_KEY == "" or _G.EXECUTOR_KEY == "your_key_here" then
    game.Players.LocalPlayer:Kick("‚ùå Invalid executor key. Please set _G.EXECUTOR_KEY before running this script.\n\nExample:\n_G.EXECUTOR_KEY = \"your_key_here\"\nloadstring(game:HttpGet(\"your_script_url\"))()")
    return
end

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RbxAnalytics = game:GetService("RbxAnalyticsService")
local player = Players.LocalPlayer

-- Enhanced Configuration - Synced with Discord Bot API and localhost endpoints
local CONFIG = {
    -- Primary API (localhost deployment)
    API_BASE = "http://localhost:80",
    
    -- Fallback URLs (including other localhost ports for development)
    FALLBACK_URLS = {
        "http://localhost:3000",
        "http://localhost:3001", 
        "http://localhost:8000",
        "http://localhost:8080",
        "http://localhost:5000"
    },
    
    -- API Endpoints matching localhost structure
    ENDPOINTS = {
        STATUS = "/api/status",
        VALIDATE_KEY = "/api/validate-key",
        PROSES = "/api/proses",
        USERS = "/api/users",
        SYNC = "/api/sync",
        LOG = "/api/log",
        AUTH = "/api/auth",
        SCRIPT = "/api/script"
    },
    
    -- Timeouts and retry configuration
    TIMEOUT = 15000, -- Reduced for local connections
    MAX_RETRIES = 3, -- Reduced for local testing
    RETRY_DELAY = 1000, -- 1 second delay between retries
    
    -- Script configuration
    EXECUTOR_KEY = _G.EXECUTOR_KEY,
    SCRIPT_URL = "https://raw.githubusercontent.com/Vogiahungpro/Lol/refs/heads/main/Lol.wtf%20main",
    GITHUB_FALLBACK = true,
    USER_AGENT = "DiscordKatabump/2.1-Localhost",
    
    -- API Features
    AUTO_RETRY = true,
    ENHANCED_LOGGING = true,
    FALLBACK_MODE = true
}

print("üöÄ Discord Bot Katabump Integration v2.1 Starting...")
print("üîë Executor Key: " .. CONFIG.EXECUTOR_KEY:sub(1, 8) .. "...")
print("üåê Primary API: " .. CONFIG.API_BASE)

-- Enhanced Discord Bot Synced Executor
local DiscordKatabumpExecutor = {}
DiscordKatabumpExecutor.__index = DiscordKatabumpExecutor

function DiscordKatabumpExecutor.new()
    local self = setmetatable({}, DiscordKatabumpExecutor)
    
    -- Core properties
    self.authenticated = false
    self.userInfo = {}
    self.executorKey = CONFIG.EXECUTOR_KEY
    self.keyValidated = false
    self.hwidBound = false
    self.discordUserId = nil
    self.whitelisted = false
    self.apiDomain = CONFIG.API_BASE
    self.usingFallback = false
    
    -- Enhanced properties
    self.retryCount = 0
    self.lastApiCall = 0
    self.apiCallCount = 0
    self.errors = {}
    self.connectionHistory = {}
    
    return self
end

-- Enhanced HTTP request function with better error handling
function DiscordKatabumpExecutor:makeHTTPRequest(url, method, data, timeout)
    local headers = {
        ["Content-Type"] = "application/json",
        ["User-Agent"] = CONFIG.USER_AGENT,
        ["X-Executor-Key"] = self.executorKey,
        ["X-HWID"] = self.userInfo.hwid or "unknown",
        ["X-API-Source"] = "roblox-lua-enhanced",
        ["X-Domain"] = self.apiDomain,
        ["Accept"] = "application/json"
    }
    
    -- Add localhost-specific headers
    if self.apiDomain:find("localhost") then
        headers["Origin"] = "http://localhost"
        headers["Cache-Control"] = "no-cache"
        headers["Connection"] = "keep-alive"
    end
    
    local success, response = pcall(function()
        local jsonData = data and HttpService:JSONEncode(data) or nil
        local requestFunc = (http_request or request or (syn and syn.request))
        
        if requestFunc then
            return requestFunc({
                Url = url,
                Method = method or "GET",
                Headers = headers,
                Body = jsonData,
                Timeout = timeout or CONFIG.TIMEOUT
            })
        else
            if method == "POST" and jsonData then
                local body = game:HttpPost(url, jsonData, Enum.HttpContentType.ApplicationJson)
                return { Body = body, StatusCode = 200 }
            else
                local body = game:HttpGet(url)
                return { Body = body, StatusCode = 200 }
            end
        end
    end)
    
    if success and response then
        local parseSuccess, responseData = pcall(function()
            return HttpService:JSONDecode(response.Body)
        end)
        
        if parseSuccess then
            return responseData, response.StatusCode
        else
            return nil, response.StatusCode, "JSON parse error"
        end
    else
        local errorMessage = tostring(response)
        if errorMessage:find("Connection refused") or errorMessage:find("ConnectFailure") then
            return nil, 0, "Connection refused"
        elseif errorMessage:find("timeout") or errorMessage:find("Timeout") then
            return nil, 408, "Request timeout"
        elseif errorMessage:find("SSL") or errorMessage:find("certificate") then
            return nil, 495, "SSL/Certificate error"
        end
        return nil, 500, errorMessage
    end
end

-- Enhanced API request with retry logic
function DiscordKatabumpExecutor:makeDiscordBotRequest(endpoint, method, data)
    local fullUrl = self.apiDomain .. endpoint
    self.apiCallCount = self.apiCallCount + 1
    
    print("üåê API Request #" .. self.apiCallCount .. " to:", fullUrl)
    print("üì§ Method:", method or "GET")
    
    for attempt = 1, CONFIG.MAX_RETRIES do
        print("üîÑ Attempt " .. attempt .. "/" .. CONFIG.MAX_RETRIES)
        
        local responseData, statusCode, errorMsg = self:makeHTTPRequest(fullUrl, method, data)
        
        -- Record connection attempt
        table.insert(self.connectionHistory, {
            url = fullUrl,
            method = method or "GET",
            attempt = attempt,
            statusCode = statusCode,
            success = responseData ~= nil,
            timestamp = os.time(),
            error = errorMsg
        })
        
        if responseData then
            print("‚úÖ API Request successful on attempt " .. attempt)
            print("üìä Response Status:", statusCode or "200")
            self.retryCount = 0 -- Reset retry count on success
            return responseData, statusCode
        else
            print("‚ùå Attempt " .. attempt .. " failed:", errorMsg or "Unknown error")
            print("üìä Status Code:", statusCode or "Unknown")
            
            -- Record error
            table.insert(self.errors, {
                endpoint = endpoint,
                attempt = attempt,
                error = errorMsg or "Unknown error",
                statusCode = statusCode,
                timestamp = os.time()
            })
            
            -- Don't retry on certain status codes
            if statusCode == 401 or statusCode == 403 or statusCode == 404 then
                print("üö´ Non-retryable error, stopping attempts")
                break
            end
            
            -- Wait before retry (except on last attempt)
            if attempt < CONFIG.MAX_RETRIES then
                print("‚è±Ô∏è Waiting " .. CONFIG.RETRY_DELAY .. "ms before retry...")
                task.wait(CONFIG.RETRY_DELAY / 1000)
            end
        end
    end
    
    self.retryCount = self.retryCount + 1
    return nil, statusCode, errorMsg
end

-- Try fallback URLs if main API fails
function DiscordKatabumpExecutor:tryFallbackUrls()
    print("üîÑ Primary API failed after " .. CONFIG.MAX_RETRIES .. " attempts, trying fallback URLs...")
    
    for i, fallbackUrl in ipairs(CONFIG.FALLBACK_URLS) do
        print("üîç Trying fallback URL (" .. i .. "/" .. #CONFIG.FALLBACK_URLS .. "):", fallbackUrl)
        
        local originalDomain = self.apiDomain
        self.apiDomain = fallbackUrl
        self.usingFallback = true
        
        local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.STATUS, "GET")
        
        if responseData and responseData.status then
            print("‚úÖ Found working API at:", fallbackUrl)
            return true
        end
        
        -- Restore original if failed
        self.apiDomain = originalDomain
    end
    
    -- Reset fallback flag if all failed
    self.usingFallback = false
    print("‚ùå No working fallback URLs found")
    return false
end

-- Get user's IP address
function DiscordKatabumpExecutor:getIP()
    local success, result = pcall(function()
        local requestFunc = (http_request or request or (syn and syn.request))
        if requestFunc then
            local res = requestFunc({
                Url = "https://api.ipify.org?format=json",
                Method = "GET",
                Headers = { ["User-Agent"] = CONFIG.USER_AGENT },
                Timeout = 5000 -- Short timeout for IP check
            })
            return res.Body
        else
            return game:HttpGet("https://api.ipify.org?format=json")
        end
    end)
    
    if success and result then
        local data
        pcall(function()
            data = HttpService:JSONDecode(result)
        end)
        if data and data.ip then
            return data.ip
        end
    end
    return "Unknown"
end

-- Enhanced user information preparation
function DiscordKatabumpExecutor:prepareUserInfo()
    print("üë§ Preparing enhanced user information...")
    
    self.userInfo = {
        -- Basic user data
        username = player.Name,
        userId = tostring(player.UserId),
        robloxUserId = player.UserId,
        robloxUsername = player.Name,
        displayName = player.DisplayName or player.Name,
        accountAge = player.AccountAge,
        
        -- Hardware and network info
        hwid = RbxAnalytics:GetClientId(),
        ip = self:getIP(),
        
        -- Game and session info
        gameId = game.GameId,
        placeId = game.PlaceId,
        jobId = game.JobId,
        timestamp = os.time(),
        
        -- Executor info
        executorKey = self.executorKey,
        executorVersion = CONFIG.USER_AGENT,
        
        -- API info
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback,
        apiCallCount = self.apiCallCount,
        
        -- Session info
        sessionId = tostring(math.random(100000, 999999)),
        clientVersion = "2.1-Localhost"
    }
    
    print("‚úÖ User info prepared:")
    print("   Username: " .. self.userInfo.username)
    print("   User ID: " .. self.userInfo.userId)
    print("   HWID: " .. self.userInfo.hwid:sub(1, 8) .. "...")
    print("   IP: " .. self.userInfo.ip)
    print("   Session ID: " .. self.userInfo.sessionId)
end

-- Enhanced API status check
function DiscordKatabumpExecutor:checkDiscordBotStatus()
    print("üì° Checking Discord Bot API status...")
    print("üîó API Domain: " .. self.apiDomain)
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.STATUS, "GET")
    
    if responseData and responseData.status then
        print("‚úÖ Discord Bot API Status:", responseData.status)
        print("üåê API Domain:", responseData.domain or self.apiDomain)
        print("üë• Total Users:", responseData.totalUsers or 0)
        print("üîë Users with Keys:", responseData.usersWithExecutorKeys or 0)
        print("üìä API Version:", responseData.apiVersion or "Unknown")
        
        -- Check for localhost deployment
        if responseData.service and responseData.service:find("Local") then
            print("üè† Running on localhost deployment")
        end
        
        -- Check features
        if responseData.customApiIntegration then
            print("üéØ Custom API Integration: Active")
        end
        
        return true
    else
        print("‚ùå Primary API failed, status code:", statusCode or "Unknown")
        return false
    end
end

-- Enhanced status check with comprehensive fallback
function DiscordKatabumpExecutor:checkDiscordBotStatusWithFallback()
    print("üì° Performing comprehensive API status check...")
    
    -- Try main API first
    local success = self:checkDiscordBotStatus()
    
    if not success then
        print("üîÑ Primary API failed, attempting fallback...")
        success = self:tryFallbackUrls()
        
        if not success then
            print("‚ùå All API endpoints failed")
            print("üìä Connection attempts made: " .. #self.connectionHistory)
            print("üîç Last error: " .. (self.errors[#self.errors] and self.errors[#self.errors].error or "Unknown"))
        end
    end
    
    return success
end

-- Enhanced executor key validation
function DiscordKatabumpExecutor:validateExecutorKey()
    if not self.userInfo.username then
        self:prepareUserInfo()
    end
    
    print("üîê Validating executor key...")
    
    local requestData = {
        userId = self.userInfo.userId,
        executorKey = self.executorKey,
        hwid = self.userInfo.hwid,
        robloxUserId = self.userInfo.robloxUserId,
        username = self.userInfo.username,
        timestamp = os.time(),
        sessionId = self.userInfo.sessionId,
        apiDomain = self.apiDomain,
        clientVersion = self.userInfo.clientVersion
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.VALIDATE_KEY, "POST", requestData)
    
    if responseData and responseData.success then
        self.keyValidated = true
        print("‚úÖ Executor Key Validation: SUCCESS")
        
        if responseData.userData then
            self.discordUserId = responseData.userData.userId
            self.whitelisted = responseData.userData.isWhitelisted
            print("üîë Key validated for Discord user:", responseData.userData.userId or "Unknown")
            print("üìã Access Level:", responseData.userData.accessLevel or "CUSTOMER")
        end
        
        return true
    else
        local errorMessage = "Executor key validation failed."
        if responseData and responseData.message then
            errorMessage = responseData.message
        elseif statusCode == 401 then
            errorMessage = "‚ùå Invalid executor key for this user.\nüîë Please check your key and try again."
        elseif statusCode == 403 then
            errorMessage = "‚ùå User not whitelisted.\nüí¨ Please redeem a key in Discord first."
        elseif statusCode == 0 then
            errorMessage = "‚ùå Cannot connect to Discord Bot API.\nüåê Please check if localhost:80 is running."
        end
        
        print("‚ùå Key validation failed:", errorMessage)
        player:Kick(errorMessage)
        return false
    end
end

-- Enhanced authentication with Discord Bot
function DiscordKatabumpExecutor:validateWithDiscordBot()
    if not self.userInfo.username then
        self:prepareUserInfo()
    end
    
    print("üîê Authenticating with Discord Bot...")
    
    -- Enhanced request data matching Discord bot expectations
    local requestData = {
        userId = self.userInfo.userId,
        key = self.executorKey,
        action = "validate_and_auth",
        hwid = self.userInfo.hwid,
        username = self.userInfo.username,
        robloxUserId = self.userInfo.robloxUserId,
        displayName = self.userInfo.displayName,
        ip = self.userInfo.ip,
        gameId = self.userInfo.gameId,
        placeId = self.userInfo.placeId,
        jobId = self.userInfo.jobId,
        timestamp = self.userInfo.timestamp,
        sessionId = self.userInfo.sessionId,
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback,
        clientVersion = self.userInfo.clientVersion,
        accountAge = self.userInfo.accountAge
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.PROSES, "POST", requestData)
    
    if responseData and responseData.success then
        self.authenticated = true
        self.keyValidated = true
        
        if responseData.userData then
            self.discordUserId = responseData.userData.userId
            self.whitelisted = responseData.userData.isWhitelisted
            
            print("‚úÖ Discord Bot Authentication: SUCCESS")
            print("üîë Executor Key: VALIDATED")
            print("üë§ Access Level:", responseData.userData.accessLevel or "CUSTOMER")
            print("üåê API Domain:", self.apiDomain)
            print("üì° Using Fallback:", self.usingFallback and "YES" or "NO")
            
            -- Enhanced logging
            if responseData.userData.fallback then
                print("‚ö†Ô∏è API Response: Using local fallback mode")
            end
            
            if responseData.userData.customApiReady then
                print("üéØ Custom API: READY")
            end
            
            return true
        else
            player:Kick("‚ùå Invalid response from Discord Bot API.\nüîÑ Please try again in a few moments.")
            return false
        end
    else
        local errorMessage = "Discord Bot authentication failed."
        if responseData and responseData.message then
            errorMessage = responseData.message
        elseif statusCode == 400 then
            errorMessage = "‚ùå Invalid executor key format.\nüîë Please check your key format."
        elseif statusCode == 401 then
            errorMessage = "‚ùå Invalid executor key for this user.\nüîë Key: " .. self.executorKey:sub(1, 8) .. "..."
        elseif statusCode == 403 then
            errorMessage = "‚ùå User not whitelisted.\nüí¨ Please redeem a key in Discord first.\nüÜî User ID: " .. self.userInfo.userId
        elseif statusCode == 0 then
            errorMessage = "‚ùå Cannot connect to Discord Bot API.\nüåê Please make sure localhost:80 is running."
        end
        
        print("‚ùå Authentication Error:", errorMessage)
        print("üåê Attempted API:", self.apiDomain)
        print("üìä Total attempts:", #self.connectionHistory)
        player:Kick(errorMessage)
        return false
    end
end

-- Enhanced data sync with Discord Bot
function DiscordKatabumpExecutor:syncWithDiscordBot()
    print("üîÑ Syncing data with Discord Bot...")
    
    local syncData = {
        userId = self.userInfo.userId,
        keyData = {
            executorKey = self.executorKey,
            hwid = self.userInfo.hwid,
            lastAccess = os.time(),
            gameId = self.userInfo.gameId,
            placeId = self.userInfo.placeId,
            sessionId = self.userInfo.sessionId,
            apiDomain = self.apiDomain,
            clientVersion = self.userInfo.clientVersion
        },
        timestamp = os.time(),
        executorKey = self.executorKey,
        action = "lua_script_access",
        source = "roblox_lua_localhost",
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback,
        connectionHistory = #self.connectionHistory,
        errorCount = #self.errors
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.SYNC, "POST", syncData)
    
    if responseData and responseData.success then
        print("‚úÖ Discord Bot Sync: SUCCESS")
        print("üåê Synced with:", self.apiDomain)
        
        if responseData.fallbackMode then
            print("‚ö†Ô∏è Sync used fallback mode")
        end
        
        return true
    else
        print("‚ö†Ô∏è Discord Bot Sync: FAILED (non-critical)")
        print("üì° Sync attempted with:", self.apiDomain)
        return false
    end
end

-- Enhanced execution logging
function DiscordKatabumpExecutor:logExecution(success, error)
    pcall(function()
        local logData = {
            userId = self.userInfo.userId,
            executorKey = self.executorKey,
            data = {
                success = success,
                error = error,
                timestamp = os.time(),
                gameId = self.userInfo.gameId,
                placeId = self.userInfo.placeId,
                hwid = self.userInfo.hwid,
                sessionId = self.userInfo.sessionId,
                apiDomain = self.apiDomain,
                usingFallback = self.usingFallback,
                apiCallCount = self.apiCallCount,
                retryCount = self.retryCount,
                connectionAttempts = #self.connectionHistory,
                errorCount = #self.errors
            },
            timestamp = os.time(),
            source = "roblox_lua_localhost",
            clientVersion = self.userInfo.clientVersion
        }
        
        self:makeDiscordBotRequest(CONFIG.ENDPOINTS.LOG, "POST", logData)
    end)
end

-- Enhanced script loading from GitHub
function DiscordKatabumpExecutor:getScriptFromGitHub()
    print("üìú Loading script from GitHub...")
    print("üîó GitHub URL: " .. CONFIG.SCRIPT_URL)
    
    local success, script = pcall(function()
        local requestFunc = (http_request or request or (syn and syn.request))
        if requestFunc then
            local response = requestFunc({
                Url = CONFIG.SCRIPT_URL,
                Method = "GET",
                Headers = { ["User-Agent"] = CONFIG.USER_AGENT },
                Timeout = CONFIG.TIMEOUT
            })
            return response.Body
        else
            return game:HttpGet(CONFIG.SCRIPT_URL)
        end
    end)
    
    if success and script and script ~= "" and not script:find("404") then
        print("‚úÖ Script loaded from GitHub")
        print("üìä Script length:", #script, "characters")
        return script
    else
        print("‚ùå Failed to load script from GitHub:", script or "Unknown error")
        return nil
    end
end

-- Try to get script from Discord Bot API
function DiscordKatabumpExecutor:getScriptFromDiscordBot()
    print("üìú Attempting to get script from Discord Bot API...")
    
    local scriptEndpoint = CONFIG.ENDPOINTS.SCRIPT .. "/" .. self.userInfo.userId .. "?key=" .. self.executorKey
    local responseData, statusCode = self:makeDiscordBotRequest(scriptEndpoint, "GET")
    
    if responseData and responseData.success and responseData.data and responseData.data.script then
        print("‚úÖ Script loaded from Discord Bot API")
        print("üìä Script length:", #responseData.data.script, "characters")
        print("üîë Executor key included:", responseData.data.executorKey and "YES" or "NO")
        return responseData.data.script
    else
        print("‚ö†Ô∏è Could not get script from Discord Bot API")
        print("üìä Status code:", statusCode or "Unknown")
        if responseData and responseData.message then
            print("üí¨ API Message:", responseData.message)
        end
        return nil
    end
end

-- Enhanced script execution
function DiscordKatabumpExecutor:executeScript(script)
    if not self.authenticated or not self.keyValidated then
        player:Kick("‚ùå Invalid authentication state.\nüîÑ Please restart the script.")
        return false
    end
    
    print("‚ö° Executing script...")
    print("üìä Script length:", #script, "characters")
    
    -- Add execution header
    local executionHeader = string.format([[
-- Discord Bot Katabump Executor
-- Authenticated: %s
-- User ID: %s
-- Executor Key: %s
-- API Domain: %s
-- Session ID: %s
-- Timestamp: %s

]], self.authenticated and "YES" or "NO", 
     self.userInfo.userId, 
     self.executorKey:sub(1, 8) .. "...", 
     self.apiDomain, 
     self.userInfo.sessionId,
     os.date("%Y-%m-%d %H:%M:%S", os.time()))
    
    local fullScript = executionHeader .. script
    
    local success, result = pcall(function()
        local func = loadstring(fullScript)
        if func then
            return func()
        else
            error("Failed to load script")
        end
    end)
    
    if success then
        self:logExecution(true)
        print("‚úÖ Script executed successfully")
        print("üåê Authenticated via:", self.apiDomain)
        print("üìä Total API calls made:", self.apiCallCount)
        return true
    else
        self:logExecution(false, tostring(result))
        print("‚ùå Script execution failed:", tostring(result))
        player:Kick("‚ùå Script execution failed:\n" .. tostring(result))
        return false
    end
end

-- Enhanced error reporting
function DiscordKatabumpExecutor:printErrorSummary()
    if #self.errors > 0 then
        print("üìä Error Summary (" .. #self.errors .. " errors):")
        for i, error in ipairs(self.errors) do
            if i <= 3 then -- Show only first 3 errors
                print("   " .. i .. ". " .. error.endpoint .. " - " .. error.error)
            end
        end
        if #self.errors > 3 then
            print("   ... and " .. (#self.errors - 3) .. " more errors")
        end
    end
end

-- Enhanced connection summary
function DiscordKatabumpExecutor:printConnectionSummary()
    print("üìä Connection Summary:")
    print("   Total API calls: " .. self.apiCallCount)
    print("   Connection attempts: " .. #self.connectionHistory)
    print("   Successful connections: " .. #(function()
        local successful = {}
        for _, conn in ipairs(self.connectionHistory) do
            if conn.success then table.insert(successful, conn) end
        end
        return successful
    end)())
    print("   Failed connections: " .. #self.errors)
    print("   Using fallback: " .. (self.usingFallback and "YES" or "NO"))
    print("   Final API domain: " .. self.apiDomain)
end

-- =============================================================================
-- MAIN EXECUTION FLOW - Enhanced with better error handling and logging
-- =============================================================================

print("üöÄ Starting Enhanced Discord Bot Katabump Integration...")
print("üîë Executor Key: " .. CONFIG.EXECUTOR_KEY:sub(1, 8) .. "...")
print("üåê Primary API: " .. CONFIG.API_BASE)
print("‚öôÔ∏è Max Retries: " .. CONFIG.MAX_RETRIES)
print("‚è±Ô∏è Timeout: " .. CONFIG.TIMEOUT .. "ms")

local executor = DiscordKatabumpExecutor.new()

-- Step 1: Check Discord Bot API status with comprehensive fallback
print("\nüì° Step 1: Checking Discord Bot API status...")
local statusSuccess = executor:checkDiscordBotStatusWithFallback()

if not statusSuccess then
    executor:printErrorSummary()
    player:Kick("‚ùå Discord Bot API is offline.\nüåê All API endpoints are unreachable.\nüîÑ Please make sure localhost:80 is running.")
    return
end

-- Step 2: Prepare user information
print("\nüë§ Step 2: Preparing user information...")
executor:prepareUserInfo()

-- Step 3: Authenticate with Discord Bot
print("\nüîê Step 3: Authenticating with Discord Bot...")
local authResult = executor:validateWithDiscordBot()

if not authResult then
    executor:printErrorSummary()
    return
end

-- Step 4: Sync data with Discord Bot (Optional but recommended)
print("\nüîÑ Step 4: Syncing data with Discord Bot...")
local syncSuccess = executor:syncWithDiscordBot()
if not syncSuccess then
    print("‚ö†Ô∏è Data sync failed, but continuing execution...")
end

-- Step 5: Load script (try Discord Bot API first, then GitHub)
print("\nüìú Step 5: Loading script...")
local script = executor:getScriptFromDiscordBot()

if not script then
    print("üîÑ Falling back to GitHub...")
    script = executor:getScriptFromGitHub()
end

if not script then
    executor:printErrorSummary()
    player:Kick("‚ùå Failed to load script from all sources.\nüåê Both API and GitHub are unreachable.\nüîÑ Please try again later.")
    return
end

-- Step 6: Execute script
print("\n‚ö° Step 6: Executing script...")
local executionSuccess = executor:executeScript(script)

if executionSuccess then
    -- Print final summary
    print("\n‚úÖ Discord Bot Katabump Integration completed successfully!")
    print("üîë Executor Key: " .. executor.executorKey:sub(1, 8) .. "...")
    print("üë§ Discord User ID: " .. (executor.discordUserId or "Unknown"))
    print("‚úÖ Whitelisted: " .. (executor.whitelisted and "YES" or "NO"))
    print("üåê Authenticated: " .. (executor.authenticated and "YES" or "NO"))
    
    -- Print connection summary
    executor:printConnectionSummary()
    
    -- Store globally for manual access and debugging
    _G.DiscordKatabumpExecutor = executor
    _G.executor = executor -- Backward compatibility
    _G.katabumpStats = {
        authenticated = executor.authenticated,
        keyValidated = executor.keyValidated,
        whitelisted = executor.whitelisted,
        discordUserId = executor.discordUserId,
        apiDomain = executor.apiDomain,
        usingFallback = executor.usingFallback,
        apiCallCount = executor.apiCallCount,
        connectionAttempts = #executor.connectionHistory,
        errorCount = #executor.errors,
        sessionId = executor.userInfo.sessionId,
        executorKey = executor.executorKey:sub(1, 8) .. "...",
        timestamp = os.time()
    }
    
    -- Enhanced debugging functions available globally
    _G.printKatabumpStatus = function()
        print("üîç Katabump Status Debug:")
        for key, value in pairs(_G.katabumpStats) do
            print("   " .. key .. ": " .. tostring(value))
        end
    end
    
    _G.printConnectionHistory = function()
        print("üìä Connection History (" .. #executor.connectionHistory .. " attempts):")
        for i, conn in ipairs(executor.connectionHistory) do
            local status = conn.success and "‚úÖ" or "‚ùå"
            print("   " .. i .. ". " .. status .. " " .. conn.method .. " " .. conn.url .. " (" .. (conn.statusCode or "N/A") .. ")")
        end
    end
    
    _G.printErrorHistory = function()
        print("üîç Error History (" .. #executor.errors .. " errors):")
        for i, error in ipairs(executor.errors) do
            print("   " .. i .. ". " .. error.endpoint .. " - " .. error.error .. " (Status: " .. (error.statusCode or "N/A") .. ")")
        end
    end
    
    _G.retryConnection = function()
        print("üîÑ Retrying connection to Discord Bot API...")
        local newExecutor = DiscordKatabumpExecutor.new()
        local success = newExecutor:checkDiscordBotStatusWithFallback()
        if success then
            print("‚úÖ Connection retry successful!")
            _G.executor = newExecutor
            return newExecutor
        else
            print("‚ùå Connection retry failed")
            return nil
        end
    end
    
    print("\nüõ†Ô∏è Debug functions available:")
    print("   _G.printKatabumpStatus() - Show current status")
    print("   _G.printConnectionHistory() - Show connection attempts")
    print("   _G.printErrorHistory() - Show error history") 
    print("   _G.retryConnection() - Retry API connection")
    
else
    executor:printErrorSummary()
end

return executor
