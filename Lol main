-- Roblox Executor Client with Discord Bot Katabump API Integration
-- Synced with index.js Discord bot endpoints and data structures
-- Updated to use lol.vercel.app API domain

if _G.executed then return end
_G.executed = true

repeat task.wait() until game:IsLoaded()

-- Check for executor key
if not _G.EXECUTOR_KEY or _G.EXECUTOR_KEY == "" or _G.EXECUTOR_KEY == "your_key_here" then
    game.Players.LocalPlayer:Kick("Invalid executor key. Please set _G.EXECUTOR_KEY before running this script.")
    return
end

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RbxAnalytics = game:GetService("RbxAnalyticsService")
local player = Players.LocalPlayer

-- Configuration - Synced with Discord Bot API (index.js)
local CONFIG = {
    -- Updated to match Discord bot configuration
    API_BASE = "https://lol.vercel.app",
    -- Fallback URLs (including localhost for development)
    FALLBACK_URLS = {
        "http://localhost:3000",
        "http://localhost:3001", 
        "http://localhost:8000",
        "http://localhost:8080",
        "http://localhost:5000"
    },
    ENDPOINTS = {
        -- Core API endpoints matching Discord bot
        STATUS = "/api/status",
        VALIDATE_KEY = "/api/validate-key",
        PROSES = "/api/proses",
        USERS = "/api/users",
        SYNC = "/api/sync",
        LOG = "/api/log",
        AUTH = "/api/auth",
        SCRIPT = "/api/script"
    },
    TIMEOUT = 15000, -- Increased for remote API
    MAX_RETRIES = 3,
    EXECUTOR_KEY = _G.EXECUTOR_KEY,
    SCRIPT_URL = "https://raw.githubusercontent.com/Vogiahungpro/Lol/refs/heads/main/Lol.wtf%20main",
    GITHUB_FALLBACK = true,
    USER_AGENT = "DiscordKatabump/2.0-Vercel"
}

-- Discord Bot Synced Executor
local DiscordKatabumpExecutor = {}
DiscordKatabumpExecutor.__index = DiscordKatabumpExecutor

function DiscordKatabumpExecutor.new()
    local self = setmetatable({}, DiscordKatabumpExecutor)
    self.authenticated = false
    self.userInfo = {}
    self.executorKey = CONFIG.EXECUTOR_KEY
    self.keyValidated = false
    self.hwidBound = false
    self.retryCount = 0
    self.discordUserId = nil
    self.whitelisted = false
    self.apiDomain = CONFIG.API_BASE
    self.usingFallback = false
    return self
end

-- Get user's IP address
function DiscordKatabumpExecutor:getIP()
    local success, result = pcall(function()
        local requestFunc = (http_request or request or (syn and syn.request))
        if requestFunc then
            local res = requestFunc({
                Url = "https://api.ipify.org?format=json",
                Method = "GET",
                Headers = { ["User-Agent"] = CONFIG.USER_AGENT }
            })
            return res.Body
        else
            return game:HttpGet("https://api.ipify.org?format=json")
        end
    end)
    
    if success and result then
        local data
        pcall(function()
            data = HttpService:JSONDecode(result)
        end)
        if data and data.ip then
            return data.ip
        end
    end
    return "Unknown"
end

-- Prepare user information (matching Discord bot expectations)
function DiscordKatabumpExecutor:prepareUserInfo()
    self.userInfo = {
        username = player.Name,
        userId = tostring(player.UserId), -- Convert to string to match Discord bot expectations
        hwid = RbxAnalytics:GetClientId(),
        ip = self:getIP(),
        timestamp = os.time(),
        gameId = game.GameId,
        placeId = game.PlaceId,
        executorVersion = CONFIG.USER_AGENT,
        executorKey = self.executorKey,
        -- Additional fields for Discord bot sync
        robloxUserId = player.UserId,
        robloxUsername = player.Name,
        displayName = player.DisplayName or player.Name,
        accountAge = player.AccountAge,
        -- API domain info
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback
    }
end

-- Make HTTP request to Discord Bot API with enhanced error handling for Vercel
function DiscordKatabumpExecutor:makeDiscordBotRequest(endpoint, method, data)
    local fullUrl = self.apiDomain .. endpoint
    
    print("üåê Making request to:", fullUrl)
    print("üì§ Method:", method or "GET")
    
    local headers = {
        ["Content-Type"] = "application/json",
        ["User-Agent"] = CONFIG.USER_AGENT,
        ["X-Executor-Key"] = self.executorKey,
        ["X-HWID"] = self.userInfo.hwid or "unknown",
        ["X-API-Source"] = "roblox-lua",
        ["X-Domain"] = self.apiDomain
    }
    
    -- Add CORS headers for Vercel
    if self.apiDomain:find("vercel.app") then
        headers["Origin"] = "https://roblox.com"
        headers["Access-Control-Request-Method"] = method or "GET"
    end
    
    local success, response = pcall(function()
        local jsonData = data and HttpService:JSONEncode(data) or nil
        if jsonData then
            print("üì¶ Request Data Length:", #jsonData, "characters")
        end
        
        local requestFunc = (http_request or request or (syn and syn.request))
        
        if requestFunc then
            print("üîß Using custom HTTP request function for", self.apiDomain)
            local result = requestFunc({
                Url = fullUrl,
                Method = method or "GET",
                Headers = headers,
                Body = jsonData,
                Timeout = CONFIG.TIMEOUT
            })
            return result
        else
            print("üîß Using Roblox HttpService for", self.apiDomain)
            if method == "POST" and jsonData then
                local body = game:HttpPost(fullUrl, jsonData, Enum.HttpContentType.ApplicationJson)
                return { Body = body, StatusCode = 200 }
            else
                local body = game:HttpGet(fullUrl)
                return { Body = body, StatusCode = 200 }
            end
        end
    end)
    
    if success and response then
        print("‚úÖ HTTP Request successful to", self.apiDomain)
        print("üì• Response Status:", response.StatusCode or "Unknown")
        print("üìä Response Length:", response.Body and #response.Body or 0, "characters")
        
        local responseData
        local parseSuccess, parseError = pcall(function()
            responseData = HttpService:JSONDecode(response.Body)
        end)
        
        if parseSuccess then
            print("‚úÖ JSON Parse successful")
            return responseData, response.StatusCode
        else
            print("‚ùå JSON Parse failed:", parseError)
            print("üìÑ Raw Response:", response.Body and response.Body:sub(1, 200) or "Empty")
            return nil, response.StatusCode
        end
    else
        print("‚ùå HTTP Request failed to", self.apiDomain, ":", response or "Unknown error")
        
        -- Specific error handling for connection issues
        if response and type(response) == "string" then
            if response:find("Connection refused") or response:find("ConnectFailure") then
                print("üö´ Connection refused to", self.apiDomain)
                return nil, 0 -- Use status code 0 for connection refused
            elseif response:find("timeout") or response:find("Timeout") then
                print("‚è±Ô∏è Request timeout to", self.apiDomain)
                return nil, 408
            elseif response:find("SSL") or response:find("certificate") then
                print("üîí SSL/Certificate error with", self.apiDomain)
                return nil, 495
            end
        end
        
        return nil, 500
    end
end

-- Try fallback URLs if main API fails
function DiscordKatabumpExecutor:tryFallbackUrls()
    print("üîÑ Primary API failed, trying fallback URLs...")
    
    for i, fallbackUrl in ipairs(CONFIG.FALLBACK_URLS) do
        print("üîç Trying fallback URL (" .. i .. "/" .. #CONFIG.FALLBACK_URLS .. "):", fallbackUrl)
        
        local originalDomain = self.apiDomain
        self.apiDomain = fallbackUrl
        self.usingFallback = true
        
        local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.STATUS, "GET")
        
        if responseData and responseData.status then
            print("‚úÖ Found working API at:", fallbackUrl)
            return true
        end
        
        -- Restore original if failed
        self.apiDomain = originalDomain
    end
    
    -- Reset fallback flag if all failed
    self.usingFallback = false
    print("‚ùå No working fallback URLs found")
    return false
end

-- Check Discord Bot API status with Vercel support
function DiscordKatabumpExecutor:checkDiscordBotStatus()
    print("üì° Checking Discord Bot API status at:", self.apiDomain)
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.STATUS, "GET")
    
    if responseData and responseData.status then
        print("‚úÖ Discord Bot API is", responseData.status)
        print("üåê API Domain:", responseData.domain or self.apiDomain)
        print("üë• Total Users:", responseData.totalUsers or 0)
        print("üîë Users with Keys:", responseData.usersWithExecutorKeys or 0)
        
        -- Check if using Vercel
        if responseData.domain and responseData.domain:find("vercel.app") then
            print("‚òÅÔ∏è Running on Vercel deployment")
        end
        
        return true
    else
        print("‚ùå Primary API failed, status code:", statusCode or "Unknown")
        
        -- Try fallback URLs
        return self:tryFallbackUrls()
    end
end

-- Enhanced status check with fallback
function DiscordKatabumpExecutor:checkDiscordBotStatusWithFallback()
    -- Try main API first (lol.vercel.app)
    print("üì° Checking primary Vercel API...")
    local success = self:checkDiscordBotStatus()
    
    if not success then
        print("üîÑ Vercel API failed, trying local fallbacks...")
        success = self:tryFallbackUrls()
    end
    
    return success
end

-- Validate executor key using /api/validate-key endpoint
function DiscordKatabumpExecutor:validateExecutorKey()
    if not self.userInfo.username then
        self:prepareUserInfo()
    end
    
    local requestData = {
        userId = self.userInfo.userId,
        executorKey = self.executorKey,
        timestamp = os.time(),
        robloxUserId = self.userInfo.robloxUserId,
        hwid = self.userInfo.hwid,
        apiDomain = self.apiDomain
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.VALIDATE_KEY, "POST", requestData)
    
    if responseData and responseData.success then
        self.keyValidated = true
        print("‚úÖ Executor Key Validation: Success")
        
        if responseData.userData then
            self.discordUserId = responseData.userData.userId
            print("üîë Key validated for user:", responseData.userData.userId)
        end
        
        return true
    else
        local errorMessage = "Executor key validation failed."
        if responseData and responseData.message then
            errorMessage = responseData.message
        elseif statusCode == 401 then
            errorMessage = "Invalid executor key for this user."
        elseif statusCode == 403 then
            errorMessage = "User not whitelisted. Please redeem a key in Discord."
        end
        
        player:Kick(errorMessage)
        return false
    end
end

-- Validate and authenticate using /api/proses endpoint (matching index.js)
function DiscordKatabumpExecutor:validateWithDiscordBot()
    if not self.userInfo.username then
        self:prepareUserInfo()
    end
    
    -- Use the /api/proses endpoint as defined in index.js
    local requestData = {
        userId = self.userInfo.userId,
        key = self.executorKey,
        action = "validate_and_auth",
        hwid = self.userInfo.hwid,
        username = self.userInfo.username,
        robloxUserId = self.userInfo.robloxUserId,
        ip = self.userInfo.ip,
        gameId = self.userInfo.gameId,
        placeId = self.userInfo.placeId,
        timestamp = self.userInfo.timestamp,
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.PROSES, "POST", requestData)
    
    if responseData and responseData.success then
        self.authenticated = true
        self.keyValidated = true
        
        if responseData.userData then
            self.discordUserId = responseData.userData.userId
            self.whitelisted = responseData.userData.isWhitelisted
            
            print("‚úÖ Discord Bot Authentication Success")
            print("üîë Executor Key Validated:", responseData.userData.executorKey or "Yes")
            print("üë§ Access Level:", responseData.userData.accessLevel or "CUSTOMER")
            print("üåê API Domain:", self.apiDomain)
            print("üì° Using Fallback:", self.usingFallback and "Yes" or "No")
            
            -- Log if using fallback mode
            if responseData.userData.fallback then
                print("‚ö†Ô∏è API Response: Using local fallback mode")
            end
            
            return true
        else
            player:Kick("Invalid response from Discord Bot API.")
            return false
        end
    else
        local errorMessage = "Discord Bot authentication failed."
        if responseData and responseData.message then
            errorMessage = responseData.message
        elseif statusCode == 400 then
            errorMessage = "Invalid executor key format."
        elseif statusCode == 401 then
            errorMessage = "Invalid executor key for this user."
        elseif statusCode == 403 then
            errorMessage = "User not whitelisted. Please redeem a key in Discord."
        elseif statusCode == 0 then
            errorMessage = "Cannot connect to Discord Bot API. Please try again later."
        end
        
        print("‚ùå Authentication Error:", errorMessage)
        print("üåê Attempted API:", self.apiDomain)
        player:Kick(errorMessage)
        return false
    end
end

-- Sync data with Discord Bot using /api/sync endpoint
function DiscordKatabumpExecutor:syncWithDiscordBot()
    local syncData = {
        userId = self.userInfo.userId,
        keyData = {
            executorKey = self.executorKey,
            hwid = self.userInfo.hwid,
            lastAccess = os.time(),
            gameId = self.userInfo.gameId,
            placeId = self.userInfo.placeId,
            apiDomain = self.apiDomain
        },
        timestamp = os.time(),
        executorKey = self.executorKey,
        action = "lua_script_access",
        source = "roblox_lua",
        apiDomain = self.apiDomain,
        usingFallback = self.usingFallback
    }
    
    local responseData, statusCode = self:makeDiscordBotRequest(CONFIG.ENDPOINTS.SYNC, "POST", syncData)
    
    if responseData and responseData.success then
        print("‚úÖ Discord Bot Sync: Data synchronized successfully")
        print("üåê Synced with:", self.apiDomain)
        
        if responseData.fallback then
            print("‚ö†Ô∏è Sync used fallback mode")
        end
        
        return true
    else
        print("‚ö†Ô∏è Discord Bot Sync: Failed to sync data (non-critical)")
        print("üì° Sync attempted with:", self.apiDomain)
        return false
    end
end

-- Log execution to Discord Bot API
function DiscordKatabumpExecutor:logExecution(success, error)
    pcall(function()
        local logData = {
            userId = self.userInfo.userId,
            executorKey = self.executorKey,
            data = {
                success = success,
                error = error,
                timestamp = os.time(),
                gameId = self.userInfo.gameId,
                placeId = self.userInfo.placeId,
                hwid = self.userInfo.hwid,
                apiDomain = self.apiDomain,
                usingFallback = self.usingFallback
            },
            timestamp = os.time(),
            source = "roblox_lua"
        }
        
        self:makeDiscordBotRequest(CONFIG.ENDPOINTS.LOG, "POST", logData)
    end)
end

-- Get script from GitHub URL
function DiscordKatabumpExecutor:getScriptFromGitHub()
    print("üìú Loading script from GitHub...")
    
    local success, script = pcall(function()
        local requestFunc = (http_request or request or (syn and syn.request))
        if requestFunc then
            local response = requestFunc({
                Url = CONFIG.SCRIPT_URL,
                Method = "GET",
                Headers = { ["User-Agent"] = CONFIG.USER_AGENT },
                Timeout = CONFIG.TIMEOUT
            })
            return response.Body
        else
            return game:HttpGet(CONFIG.SCRIPT_URL)
        end
    end)
    
    if success and script and script ~= "" then
        print("‚úÖ Script loaded from GitHub successfully")
        print("üìä Script length:", #script, "characters")
        return script
    else
        print("‚ùå Failed to load script from GitHub:", script or "Unknown error")
        player:Kick("Failed to load script from GitHub. Please try again.")
        return nil
    end
end

-- Try to get script from Discord Bot API (if available)
function DiscordKatabumpExecutor:getScriptFromDiscordBot()
    print("üìú Attempting to get script from Discord Bot API...")
    
    local scriptEndpoint = CONFIG.ENDPOINTS.SCRIPT .. "/" .. self.userInfo.userId .. "?key=" .. self.executorKey
    local responseData, statusCode = self:makeDiscordBotRequest(scriptEndpoint, "GET")
    
    if responseData and responseData.success and responseData.data and responseData.data.script then
        print("‚úÖ Script loaded from Discord Bot API")
        print("üìä Script length:", #responseData.data.script, "characters")
        return responseData.data.script
    else
        print("‚ö†Ô∏è Could not get script from Discord Bot API, falling back to GitHub")
        return nil
    end
end

-- Execute script with validation
function DiscordKatabumpExecutor:executeScript(script)
    if not self.authenticated or not self.keyValidated then
        player:Kick("Invalid authentication state. Please restart.")
        return false
    end
    
    print("‚ö° Executing script...")
    
    local success, result = pcall(function()
        local func = loadstring(script)
        if func then
            return func()
        else
            error("Failed to load script")
        end
    end)
    
    if success then
        self:logExecution(true)
        print("‚úÖ Script executed successfully")
        print("üåê Authenticated via:", self.apiDomain)
        return true
    else
        self:logExecution(false, tostring(result))
        print("‚ùå Script execution failed:", tostring(result))
        player:Kick("Script execution failed: " .. tostring(result))
        return false
    end
end

-- Main execution flow with enhanced Vercel support
print("üöÄ Starting Discord Bot Katabump Integration (Vercel Edition)...")
print("üåê Primary API: " .. CONFIG.API_BASE)

local executor = DiscordKatabumpExecutor.new()

-- Step 0: Check Discord Bot API status (Vercel + Fallback)
print("üì° Checking Discord Bot API status...")
if not executor:checkDiscordBotStatusWithFallback() then
    player:Kick("Discord Bot API is offline. Please try again later.")
    return
end

-- Step 1: Prepare user info
print("üë§ Preparing user information...")
executor:prepareUserInfo()

-- Step 2: Validate and authenticate with Discord Bot
print("üîê Authenticating with Discord Bot...")
local authResult = executor:validateWithDiscordBot()
if authResult ~= true then
    return
end

-- Step 3: Sync data with Discord Bot (Optional but recommended)
print("üîÑ Syncing data with Discord Bot...")
executor:syncWithDiscordBot()

-- Step 4: Get script (try Discord Bot API first, then GitHub)
print("üìú Loading script...")
local script = executor:getScriptFromDiscordBot()
if not script then
    script = executor:getScriptFromGitHub()
end

if script then
    print("‚ö° Executing script...")
    executor:executeScript(script)
else
    return
end

-- Store globally for manual access
_G.DiscordKatabumpExecutor = executor
_G.executor = executor -- Backward compatibility

print("‚úÖ Discord Bot Katabump Integration completed successfully!")
print("üîë Executor Key: " .. executor.executorKey:sub(1, 8) .. "...")
print("üë§ Discord User ID: " .. (executor.discordUserId or "Unknown"))
print("‚úÖ Whitelisted: " .. (executor.whitelisted and "Yes" or "No"))
print("üåê Authenticated: " .. (executor.authenticated and "Yes" or "No"))
print("üì° API Domain: " .. executor.apiDomain)
print("üîÑ Using Fallback: " .. (executor.usingFallback and "Yes" or "No"))

return executor
